import spydrnet as sdn
from spydrnet.util.selection import Selection


def identify_reduction_points(replicas,suffix):
    '''
    Looks through a replicated design and identifies any spots where reduction voters are needed.

    :param replicas: the map from an original element to its replicas generated by apply_nmr()
    :param suffix: string appended to the replicated instances' names e.g. 'TMR' or 'DWC'
    :return: list of output pins of each instance that outputs to a non_replicated element
    '''
    total_point_count = 0
    insertion_points = []
    for primary in replicas:
        if primary.__class__ is sdn.Instance and primary.is_leaf():
            for port in primary.get_ports():
                if not get_and_compare_next_instances(port,primary,replicas[primary],suffix):
                    total_point_count += 1
                    pins_to_append = list(pin for pin in port.get_pins(selection=Selection.OUTSIDE,filter=lambda x:x.instance is primary))
                    insertion_points += pins_to_append

    print("Identified {} insertion points for reduction voters.".format(total_point_count))
    return insertion_points

def get_and_compare_next_instances(current_port,primary,replicas,suffix):
    next_instances_original = []
    next_instances_replicated = []
    port_name = current_port.name
    for original_pin in get_output_pins(primary,port_name):
        next_instances_original += get_next_instances(original_pin,suffix)
    replica_pins = []
    for replica in replicas:
        replica_pins += list(x for x in get_output_pins(replica,port_name))
    for replicated_pin in replica_pins:
        next_instances_replicated += get_next_instances(replicated_pin,suffix)
    if not compare_next_instances(next_instances_original,next_instances_replicated):
        return False
    return True

def get_next_instances(current_pin,suffix):
    next_instances = []
    next_instances = list(pin2 for pin2 in current_pin.wire.get_pins(selection = Selection.OUTSIDE, filter = lambda x: (x is not current_pin)))
    next_instances = list(fix_instance_name(x.instance,suffix) for x in next_instances)
    return next_instances

def get_output_pins(current_instance,port_name):
    output_pins = []
    for pin in current_instance.get_pins(selection=Selection.OUTSIDE,filter=lambda x: (x.inner_pin.port.direction is sdn.OUT and port_name in x.inner_pin.port.name)is True):
        if pin.wire:
            output_pins.append(pin)
    return output_pins

def fix_instance_name(current_instance,suffix):
    modified_name = None
    start_index = current_instance.name.find(suffix)
    stop_index = start_index + len(suffix) + 2
    if start_index is -1:
        modified_name = current_instance.name
    else :
        modified_name = current_instance.name[:start_index-1] + current_instance.name[stop_index:]
    return modified_name

def compare_next_instances(next_instances_original,next_instances_replicated):
    if set(next_instances_original) != set(next_instances_replicated):
        return False
    return True
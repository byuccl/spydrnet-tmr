import spydrnet as sdn
from spydrnet.util.selection import Selection

def identify_reduction_points(replicas,suffix):
    '''
    Looks through a replicated design and identifies any spots where reduction voters are needed.

    :param replicas: the map from an original element to its replicas generated by apply_nmr()
    :param suffix: string appended to the replicated instances' names e.g. 'TMR' or 'DWC'
    :return: list of (source pin, sink pins) tuples where instances output to non_replicated elements
    '''
    insertion_points = []
    pinmap = _generate_pinmap(replicas)
    ignore_types = ['VCC','GND','CLK']
    for primary in pinmap.keys():
        if not any(ignore in primary.instance.name for ignore in ignore_types):
            if primary.inner_pin.port.direction is sdn.OUT:
                insertion_points += get_and_compare_next_instances(primary,pinmap[primary],suffix)

    insertion_points = compress_insertion_points(insertion_points)
    print("Identified {} insertion points for reduction voters.".format(len(insertion_points)))
    return insertion_points

def _generate_pinmap(the_replicas):
    pinmap = dict()
    for original, replicas in the_replicas.items():
        # if isinstance(original, sdn.Port):
        #     other_pins = list(x.pins for x in replicas)
        #     for pins in zip(original.pins, *other_pins):
        #         pinmap[pins[0]] = list(pins[1:])
        if isinstance(original, sdn.Instance):
            reference = original.reference
            for port in reference.ports:
                for pin in port.pins:
                    pinmap[original.pins[pin]] = list(x.pins[pin] for x in replicas)
    return pinmap

def get_and_compare_next_instances(primary,other_pins,suffix):
    next_instances_original = []
    next_instances_replicated = []
    next_instances_original = get_next_instances(primary)
    for pin in other_pins:
        next_instances_replicated += get_next_instances(pin)
    return compare_next_instances(primary,next_instances_original,next_instances_replicated,suffix)

def get_next_instances(current_pin):
    next_instances = []
    if current_pin.wire:
        next_instances = list(pin2 for pin2 in current_pin.wire.get_pins(selection=Selection.OUTSIDE,filter=lambda x:(x is not current_pin)))
    return next_instances

def fix_instance_name(current_instance,suffix):
    modified_name = None
    start_index = current_instance.name.find(suffix)
    stop_index = start_index + len(suffix) + 2
    if start_index is -1:
        modified_name = current_instance.name
    else :
        modified_name = current_instance.name[:start_index-1] + current_instance.name[stop_index:]
    return modified_name

def compare_next_instances(current_output_pin,next_instances_original,next_instances_replicated,suffix):
    reduction_points = []
    next_instances_replicated_names = list(fix_instance_name(x.instance,suffix) for x in next_instances_replicated)
    # next_instances_orginal_names = list(fix_instance_name(x.instance,suffix) for x in next_instances_original)
    for pin in next_instances_original:
        if fix_instance_name(pin.instance,suffix) not in next_instances_replicated_names:
            if pin.instance.is_top_instance or pin.instance.reference is current_output_pin.instance.parent:
                reduction_points.append((current_output_pin,frozenset([pin.inner_pin])))
            else:
                reduction_points.append((current_output_pin,frozenset([pin])))
    return reduction_points

def compress_insertion_points(points):
    reduction_dict = dict()
    for point in points:
        if point[0] in reduction_dict.keys():
            reduction_dict[point[0]]+=list(x for x in point[1])
        else:
            reduction_dict[point[0]] = list(x for x in point[1])
    reduction_points = []
    for key in reduction_dict.keys():
        reduction_points.append((key,frozenset(list(x for x in reduction_dict[key]))))
    return reduction_points

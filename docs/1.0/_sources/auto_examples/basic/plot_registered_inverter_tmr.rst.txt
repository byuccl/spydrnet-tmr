
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/basic/plot_registered_inverter_tmr.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_basic_plot_registered_inverter_tmr.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_basic_plot_registered_inverter_tmr.py:


Registered Inverter TMR Example
=============================================

In this example, there is a global clock buffer that is triplicated. This allows 
for a global clock buffer for each TMR domain in case a BUFG fails. It is 
possible that a synchronous element in the design may not be triplicated, 
and needs a signal from a BUFG. When a synchronous element that receives a 
signal from a BUFG is not triplicated, special care needs to be taken to ensure 
that a voter is not placed in its path, but rather that the non-replicated 
synchronous element just receives its clock signal from the primary TMR domain. 
If a voter is placed in its path, this could result in large hold time 
violations

This is a good example of how to use SpyDrNet TMR to selectively replicate a 
design and still maintain performance by controlling the placement of voters.


.. GENERATED FROM PYTHON SOURCE LINES 19-76




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Identified 4 insertion points for reduction voters.






|

.. code-block:: default

    from spydrnet.uniquify import uniquify
    import spydrnet_tmr
    from spydrnet_tmr.apply_tmr_to_netlist import apply_tmr_to_netlist
    from spydrnet_tmr.support_files.vendor_names import XILINX


    def run():
        """
        Generate netlist with no voters after BUFGs
        """
        netlist_name = "registered_inverter"

        non_replicated_instance_names = {
            "DQ_reg[1]",
        }
    
        generate_tmr_netlist(netlist_name, non_replicated_instance_names)


    def generate_tmr_netlist(netlist_name, non_replicated_instance_names):
        """
        Generate a TMR netlist

        """
        netlist = spydrnet_tmr.load_example_netlist_by_name(netlist_name)
        uniquify(netlist)

        # Find hierarchical references to all leaf finstances and exclude the given
        # non-replicated instances from the list
        hinstances_to_replicate = list(
            netlist.get_hinstances(
                recursive=True,
                filter=lambda x: x.item.reference.is_leaf() is True
                and x.item.name not in non_replicated_instance_names
            )
        )

        # Find hierarchical references to top-level ports
        hinstances_at_valid_voter_locations = list(
            x
            for x in hinstances_to_replicate
            if x.item.reference.name not in {"BUFG"}
        )

        apply_tmr_to_netlist(
            netlist,
            XILINX,
            hinstances_to_replicate=hinstances_to_replicate,
            hinstances_at_valid_voter_locations=hinstances_at_valid_voter_locations,
        )

        netlist_tmr_name = netlist_name + "_tmr"

        netlist.compose(netlist_tmr_name + ".edf")


    run()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.092 seconds)


.. _sphx_glr_download_auto_examples_basic_plot_registered_inverter_tmr.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_registered_inverter_tmr.py <plot_registered_inverter_tmr.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_registered_inverter_tmr.ipynb <plot_registered_inverter_tmr.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
